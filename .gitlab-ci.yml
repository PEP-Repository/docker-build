stages:
  - docker-image
  - generate-lockfile
  - conan-install
  - analyze
  - deploy
  - analyze-manual

variables:
  DOCKER_DRIVER: overlay2 # faster docker builds, see https://gitlab.com/gitlab-org/gitlab-ce/issues/21374, https://docs.docker.com/storage/storagedriver/overlayfs-driver/
  DOCKER_TLS_CERTDIR: "" # Work around failing CI jobs: see https://gitlab.com/gitlab-org/gitlab-ce/issues/64959#note_194582424
  FF_SCRIPT_SECTIONS: 'true'  # Enable collapsible sections per script line, with timings

  PROJECT_REGISTRY: $CI_REGISTRY/$CI_PROJECT_PATH
  IMAGE_TAG_PREFIX: sha-
  IMAGE_TAG_PREFIX_TEST: test-sha-
  IMAGE_TAG: $IMAGE_TAG_PREFIX$CI_COMMIT_SHA
  IMAGE_TAG_TEST: $IMAGE_TAG_PREFIX_TEST$CI_COMMIT_SHA

  FOSS_PROJECT: pep/core
  FOSS_REF:
    value: $CI_COMMIT_BRANCH
    description: Override to set branch/ref of the PEP FOSS repo to test images on & commit to (for a branch)

  IMAGE_MAX_AGE_DAYS:
    value: '6'
    description:
      If the previous image for a commit is at least this old, it will be rebuilt.
      Set to 0 to force rebuild

  UPDATE_LOCKFILE:
    value: 'yes'
    options:
      - ''
      - 'yes'
    description: Update conan-ci.lock
  FORCE_TEST:
    value: ''
    options:
      - ''
      - 'yes'
    description: Run test-images not only in scheduled pipelines
  FORCE_COMMIT:
    value: ''
    options:
      - ''
      - 'yes'
    description: Commit docker-build submodule & lockfile update not only in scheduled pipelines

  # This is a YAML space-separated string, equivalent to >-, see https://yaml-multiline.info/
  # Images that should be retagged from $IMAGE_TAG_TEST to $IMAGE_TAG
  DEPLOY_IMAGES:
    builder-ubuntu-2204
    builder-ubuntu-rolling
    builder-flatpak
    runtime-ubuntu-2204

# Applies to whole pipeline
workflow:
  rules:
    # Do not create MR pipelines (see https://docs.gitlab.com/ee/ci/pipelines/merge_request_pipelines.html ).
    # As soon as we use one `rules:` tag in a job, that job would run on any MR pipeline, unless specified otherwise.
    # Prevent that by disabling the whole pipeline in this case
    - if: $CI_PIPELINE_SOURCE != 'merge_request_event'

#language=sh
.docker_login: &docker_login
  docker login -u gitlab-ci-token -p "$CI_JOB_TOKEN" "$CI_REGISTRY"
#language=sh
.git_colors: &git_colors
  git config --global color.ui always

# You can set a tag `limit_concurrency:<VALUE>` on a gitlab runner if it runs out of memory.
# Jobs can invoke this anchor to retrieve the configured <VALUE> (if any) into the "concurrency_limit" variable.
#language=sh
.set_concurrency_limit: &set_concurrency_limit |
  apk add --no-cache jq
  concurrency_limit=$(echo "$CI_RUNNER_TAGS" | jq -r '.[]' | sed -n 's/^limit_concurrency:\([0-9]\+\)$/\1/p')
  if [ -z "$concurrency_limit" ]; then
    echo 'No concurrency limit specified'
  else
    echo "Concurrency limit is $concurrency_limit"
  fi


# ==== Build base images ====

# Build & push Docker image
.docker-image:
  stage: docker-image
  tags:
    - docker-small
  image: docker
  variables:
    CONTAINER_IMAGE: $PROJECT_REGISTRY/$IMAGE_KIND-$IMAGE_NAME:$IMAGE_TAG_TEST
  services:
    - docker:dind
  #language=sh
  before_script:
    - touch "$CI_PROJECT_DIR/env.env"
    - apk add --no-cache jq coreutils  # Also add coreutils for `date` (Alpine/busybox date doesn't parse ISO-8601 well)
    - *docker_login
    - prev_created="$(docker buildx imagetools inspect "$PROJECT_REGISTRY/$IMAGE_KIND-$IMAGE_NAME:$IMAGE_TAG" --format '{{json .Image}}' | jq --raw-output .created || true)"
    - if [ -n "$prev_created" ]; then
    -   diff_secs="$(($(date +%s) - $(date -d "$prev_created" +%s)))"
    -   diff_days="$((diff_secs / 60 / 60 / 24))"
    -   echo "Previous image created at $prev_created, $diff_days days ($diff_secs s) ago"
    -   if [ "$diff_days" -lt "$IMAGE_MAX_AGE_DAYS" ]; then
    -     echo "Recent enough, won't rebuild"
    -     exit
    -   else
    -     echo 'Not recent enough, will rebuild'
    -   fi
    - else
    -   echo 'No existing image for this commit'
    - fi
    - echo 'NEW_IMAGE=yes' >>"$CI_PROJECT_DIR/env.env"  # Save, see artifacts
    - echo "Tagging image as $CONTAINER_IMAGE"
  #language=sh
  script:
    - echo '==== Building & pushing image ===='
    - docker buildx build
      --pull
      --push
      --file "./$IMAGE_KIND/$IMAGE_NAME.Dockerfile"
      --tag "$CONTAINER_IMAGE"
      $DOCKER_ARGS
      "./$IMAGE_KIND/"
  artifacts:
    reports:
      # Save $NEW_IMAGE for jobs below
      dotenv: env.env

builder/base/ubuntu-2204:
  extends: .docker-image
  variables:
    IMAGE_KIND: builder
    IMAGE_NAME: ubuntu-2204

builder/base/ubuntu-rolling:
  extends: .docker-image
  variables:
    IMAGE_KIND: builder
    IMAGE_NAME: ubuntu-rolling

builder/base/flatpak:
  extends: .docker-image
  variables:
    IMAGE_KIND: builder
    IMAGE_NAME: flatpak

runtime/ubuntu-2204:
  extends: .docker-image
  variables:
    IMAGE_KIND: runtime
    IMAGE_NAME: ubuntu-2204


# ==== Generate lockfile ====

.generate-lockfile:
  stage: generate-lockfile
  rules:
    - if: $UPDATE_LOCKFILE
  variables:
    IMAGE_KIND: builder
    CLICOLOR_FORCE: '1'  # Colored output for Conan
  # This script must work with both bash and powershell
  #language=sh
  script:
    - cd "./$IMAGE_KIND/conan/"
    - conan lock create ./ --update
      --profile:all=./conan_profile
      --lockfile=''
      --lockfile-out=./conan-rel.lock
      -s build_type=Release
      -o "&:with_client=True"
      -o "&:with_tests=True"
      -o "&:with_benchmark=True"
      -o "&:use_system_qt=False"
    - conan lock create ./ --update
      --profile:all=./conan_profile
      --lockfile=''
      --lockfile-out=./conan-dbg.lock
      -s "&:build_type=Debug"
      -o "&:with_client=True"
      -o "&:with_tests=True"
      -o "&:with_benchmark=True"
      -o "&:use_system_qt=False"
    - conan lock merge
      --lockfile=./conan-rel.lock
      --lockfile=./conan-dbg.lock
      --lockfile-out="./conan.$name.lock"
  artifacts:
    paths:
      - ./$IMAGE_KIND/conan/conan.$name.lock

.generate-lockfile-docker:
  extends: .generate-lockfile
  tags:
    - docker-small
  image: $PROJECT_REGISTRY/builder-$name:$IMAGE_TAG_TEST

builder/lockfile/ubuntu-2204:
  extends: .generate-lockfile-docker
  needs:
    - builder/base/ubuntu-2204
  variables:
    name: ubuntu-2204

builder/lockfile/ubuntu-rolling:
  extends: .generate-lockfile-docker
  needs:
    - builder/base/ubuntu-rolling
  variables:
    name: ubuntu-rolling

builder/lockfile/windows:
  extends: .generate-lockfile
  needs: []
  tags:
    - windows
  variables:
    name: windows

builder/lockfile/macos-arm:
  extends: .generate-lockfile
  needs: []
  tags:
    - macos-arm
  variables:
    name: macos-arm

builder/lockfile/macos-x86:
  extends: .generate-lockfile
  needs: []
  tags:
    - macos-x86
  variables:
    name: macos-x86

# Currently we don't incorporate the Flatpak here because it should generally be identical to Ubuntu LTS
merge-lockfiles:
  stage: generate-lockfile
  needs:
    - builder/lockfile/ubuntu-2204
    - builder/lockfile/ubuntu-rolling
    - builder/lockfile/windows
    - builder/lockfile/macos-arm
    - builder/lockfile/macos-x86
  rules:
    - if: $UPDATE_LOCKFILE
  variables:
    IMAGE_KIND: builder
  tags:
    - docker-small
  image: $PROJECT_REGISTRY/builder-ubuntu-2204:$IMAGE_TAG_TEST
  #language=bash
  script:
    - echo "MERGE_LOCKFILES_JOB=$CI_JOB_ID" >>"$CI_PROJECT_DIR/env.env"  # Save, see artifacts
    - *git_colors
    - cd "./$IMAGE_KIND/conan/"
    - jobs=(
        ubuntu-2204
        ubuntu-rolling
        windows
        macos-arm
        macos-x86
      )
    - |
      merge_flags=()
      for name in "${jobs[@]}"; do
        merge_flags+=("--lockfile=./conan.$name.lock")
      done
    # We don't call this file conan.lock, such that it won't be picked up automatically
    # when running conan with this conanfile (and not a symlink).
    # We don't necessarily want to always use the lockfile on devboxes
    - conan lock merge "${merge_flags[@]}" --lockfile-out=./conan-ci.lock
    # Also make git diff work for new files
    - git add --intent-to-add ./conan-ci.lock
    - |
      diff_exit=0; git diff --exit-code ./conan-ci.lock || diff_exit="$?"
      case "$diff_exit" in
        0) echo 'conan-ci.lock did not change' ;;
        1) echo 'LOCKFILE_CHANGED=yes' >>"$CI_PROJECT_DIR/env.env" ;;  # Save if changed, see artifacts
        *) exit "$diff_exit" ;;
      esac
    - cp ./conan-ci.lock ../../
  artifacts:
    paths:
      - ./$IMAGE_KIND/conan/conan-ci.lock
      - ./conan-ci.lock
    reports:
      # Save $MERGE_LOCKFILES_JOB, $LOCKFILE_CHANGED for jobs below
      dotenv: env.env


# ==== Install dependencies with Conan ====

.conan-builder:
  stage: conan-install
  rules:
    - if: $UPDATE_LOCKFILE
      needs:
        - merge-lockfiles
    - when: on_success
  tags:
    - docker
  image: docker
  variables:
    IMAGE_KIND: builder
    CONTAINER_IMAGE: $PROJECT_REGISTRY/$IMAGE_KIND-$IMAGE_NAME:$IMAGE_TAG_TEST
  services:
    - docker:dind
  #language=sh
  script:
    - *set_concurrency_limit
    - *docker_login
    - echo '==== Executing Conan in container ===='
    - container="$(docker container run --pull=always --interactive --detach "$CONTAINER_IMAGE")"
    - if [ -d "./$IMAGE_KIND/cache/conan-home/" ]; then
    -   echo 'Copying cached .conan2 folder'
    -   docker cp "./$IMAGE_KIND/cache/conan-home/" "$container:/root/.conan2/"
    - fi
    - docker container cp ."/$IMAGE_KIND/conan/" "$container:/tmp/conan"
    - docker container exec "$container" /tmp/conan/conan_install.sh "$concurrency_limit"
    - docker container exec "$container" rm -rf '/tmp/*'
    - rm -rf "./$IMAGE_KIND/cache/conan-home/"
    - mkdir -p "./$IMAGE_KIND/cache/"
    - docker container cp "$container:/root/.conan2/" "./$IMAGE_KIND/cache/conan-home"
    - docker container stop "$container"
    - docker container commit --message 'Add Conan packages' "$container" "$CONTAINER_IMAGE"

    - echo "==== Pushing image ===="
    - docker push "$CONTAINER_IMAGE"
  cache:
    key: docker-builder-cache
    paths:
      - ./$IMAGE_KIND/cache/

builder/ubuntu-2204:
  extends: .conan-builder
  variables:
    IMAGE_NAME: ubuntu-2204

builder/ubuntu-rolling:
  extends: .conan-builder
  variables:
    IMAGE_NAME: ubuntu-rolling

builder/flatpak:
  stage: conan-install
  needs:
    - builder/base/flatpak
  rules:
    - if: $UPDATE_LOCKFILE
      needs:
        - builder/base/flatpak
        - merge-lockfiles
    - when: on_success
  tags:
    - docker
  image: docker
  variables:
    IMAGE_KIND: builder
    IMAGE_NAME: flatpak
    CONTAINER_IMAGE: $PROJECT_REGISTRY/$IMAGE_KIND-$IMAGE_NAME:$IMAGE_TAG_TEST
  services:
    - docker:dind
  #language=sh
  script:
    - *set_concurrency_limit
    - *docker_login
    - echo '==== Executing Flatpak Builder with Conan in container ===='
    # --privileged is necessary for flatpak-builder, see https://github.com/flatpak/flatpak-builder/issues/237
    - container="$(docker container run --pull=always --privileged --interactive --detach "$CONTAINER_IMAGE")"
    #TODO Cache ~/.conan2 like above?
    - docker container cp "./$IMAGE_KIND/flatpak/" "$container:/tmp/flatpak"
    - docker container cp "./$IMAGE_KIND/conan/" "$container:/tmp/conan"
    - |
      if [ -n "$concurrency_limit" ]; then
        concurrency_option="--jobs=$concurrency_limit"
      fi
    # Generate base image for nl.ru.cs.pep.client.yml and save as /pep-base.flatpak
    - docker container exec "$container" flatpak-builder $concurrency_option --repo /tmp/flatpak/repo /tmp/flatpak/build /tmp/flatpak/nl.ru.cs.pep.base.yml
    - docker container exec "$container" flatpak build-bundle /tmp/flatpak/repo /pep-base.flatpak nl.ru.cs.pep.base --runtime-repo=https://flathub.org/repo/flathub.flatpakrepo
    - docker container exec "$container" rm -rf '/tmp/*'
    - docker container stop "$container"
    - docker container commit --message 'Build base flatpak with Conan packages' "$container" "$CONTAINER_IMAGE"

    - echo '==== Pushing image ===='
    - docker push "$CONTAINER_IMAGE"


# ==== Analyze ====

test-images:
  stage: analyze
  rules:
    # Enable if we force it to
    - if: $FORCE_TEST
    # Enable on scheduled pipelines
    - if: $CI_PIPELINE_SOURCE == 'schedule'
  tags:
    - docker-small
  image: alpine
  #language=sh
  script:
    # We don't check $NEW_IMAGE here, because we want to make sure that when a commit is added to a different branch,
    #  we run a pipeline in PEP FOSS in the corresponding branch
    - apk add --no-cache jq curl
    - ./run-pipeline.sh "$IMAGE_TAG_TEST" "$FOSS_REF" "$MERGE_LOCKFILES_JOB"

test-images-manual:
  stage: analyze-manual
  when: manual
  tags:
    - docker-small
  image: alpine
  #language=sh
  script:
    - apk add --no-cache jq curl
    - tag="$IMAGE_TAG"
    - if [ -n "$LOCKFILE_CHANGED" ]; then
    -   echo 'Lockfile changed, will use test images'
    -   tag="$IMAGE_TAG_TEST"
    - fi
    - ./run-pipeline.sh "$tag" "$FOSS_REF" "$MERGE_LOCKFILES_JOB"


# ==== Deploy ====

# Retag test images as non-test
retag-images:
  stage: deploy
  tags:
    - docker-small
  image: docker
  variables:
    GIT_STRATEGY: none  # Do not fetch nor clean working tree
  #language=sh
  script:
    # A better way to skip jobs is not yet available, see https://gitlab.com/gitlab-org/gitlab/-/issues/292816, https://gitlab.com/gitlab-org/gitlab/-/issues/329217
    # $NEW_IMAGE, $LOCKFILE_CHANGED are retrieved from jobs above via env.env
    - if [ -z "$NEW_IMAGE" ]; then exit; fi
    - |
      if [ -n "$LOCKFILE_CHANGED" ]; then
        echo "Lockfile changed, won't retag images as ours for this commit"
        exit
      fi
    - *docker_login
    - |
      for image in $DEPLOY_IMAGES; do
        echo "Retagging $image:$IMAGE_TAG_TEST as $PROJECT_REGISTRY/$image:$IMAGE_TAG"
        # This assumes test tags of an image will not be cleaned up if it is still recent and thus reused
        docker buildx imagetools create "$PROJECT_REGISTRY/$image:$IMAGE_TAG_TEST" --tag "$PROJECT_REGISTRY/$image:$IMAGE_TAG"
      done

# Commit updated lockfile if applicable
# Update docker-build submodule in PEP FOSS
commit-update:
  stage: deploy
  needs:
    - retag-images
  rules:
    # Enable if we force it to
    # Enable on scheduled pipelines
    - if: $FORCE_COMMIT == '' && $CI_PIPELINE_SOURCE != 'schedule'
      when: never
    - if: $UPDATE_LOCKFILE
      needs:
        - retag-images
        - merge-lockfiles
    - when: on_success
  tags:
    - docker-small
  image: docker
  variables:
    GIT_STRATEGY: none  # Do not fetch nor clean working tree
  #language=sh
  script:
    - |
      if [ -z "$FORCE_COMMIT" -a -z "$LOCKFILE_CHANGED" ]; then
        echo "Lockfile did not change, won't commit"
        exit
      fi
    - |
      if [ -z "$CI_COMMIT_BRANCH" ]; then
        >&2 echo 'Pipeline is not for a branch, cannot commit'
        exit 1
      fi

    # ==== Checkout PEP FOSS repo + docker-build submodule ====
    - apk add --no-cache git
    - *git_colors
    # Do not put token in the URL to prevent it from being printed on clone
    - |
      cat >./git-password.sh <<'EOF'
      #!/usr/bin/env sh
      exec echo "$GITLAB_ACCESS_TOKEN"
      EOF
      chmod +x ./git-password.sh
      git config --global core.askPass "$PWD/git-password.sh"
    - |
      git config --global user.email support@pep.cs.ru.nl
      git config --global user.name "Gitlab CI script from $CI_PROJECT_NAME"
      git config --global push.autoSetupRemote true  # Set remote branch when pushing
    - rm -rf ./pep
    # --sparse: Sparse checkout: do not checkout all subdirectories on the disk
    # --depth=1: Shallow clone: do not fetch history
    - git clone --branch="$FOSS_REF"
      --sparse
      --no-tags
      --depth=1
      --shallow-submodules
      --recurse-submodules=docker-build
      "$CI_SERVER_URL/$FOSS_PROJECT.git" ./pep
    - cd ./pep/

    # ==== Update docker-build submodule ====
    - echo "Updating $CI_PROJECT_NAME"
    - cd ./docker-build/
    # Is the commit SHA from this pipeline the head of our branch?
    - git fetch origin "$CI_COMMIT_BRANCH"
    - branch_head="$(git rev-parse FETCH_HEAD)"
    - |
      if [ "$branch_head" != "$CI_COMMIT_SHA" ]; then
        >&2 echo "This ($CI_COMMIT_SHA) is not the newest $CI_PROJECT_NAME commit, $branch_head is newer"
        exit 1
      fi
    # Before committing, make sure we are on a branch
    - git checkout -B "$CI_COMMIT_BRANCH" "$branch_head"
    - if [ -n "$LOCKFILE_CHANGED" ]; then
    -   mv -f "$CI_PROJECT_DIR/conan-ci.lock" ./builder/conan/
    -   git add .; git status
    -   |
        git commit -m "Update conan-ci.lock for pipeline $CI_PIPELINE_ID
        $CI_JOB_URL"
    - fi
    - docker_build_commit="$(git rev-parse HEAD)"
    - cd ../

    # ==== Update PEP FOSS repo ====
    - echo "Updating $FOSS_PROJECT"
    # We just updated the submodule, now update the image tag as well
    - git sparse-checkout add ci_cd/
    - runner_image_yml=./ci_cd/docker-common.yml
    - sed --in-place "s/\(RUNNER_IMAGE_TAG:\s*\)\S*/\1$IMAGE_TAG_PREFIX$docker_build_commit/" "$runner_image_yml"
    - |
      diff_exit=0; git diff --no-patch --exit-code "$runner_image_yml" || diff_exit="$?"
      case "$diff_exit" in
        0) # No differences
          >&2 echo "Failed to update $runner_image_yml in $FOSS_PROJECT"
          exit 1 ;;
        1) ;;
        *) exit "$diff_exit" ;;
      esac
    - git add .; git status
    - |
      git commit -m "Update docker-build for pipeline $CI_PIPELINE_ID
      $CI_JOB_URL"

    # ==== Retag built images for created docker-build commit ====
    - echo "Retagging images just built as those for the new $CI_PROJECT_NAME commit"
    - *docker_login
    - |
      for image in $DEPLOY_IMAGES; do
        echo "Retagging $image:$IMAGE_TAG_TEST as $PROJECT_REGISTRY/$image:$IMAGE_TAG_PREFIX_TEST$docker_build_commit"
        docker buildx imagetools create "$PROJECT_REGISTRY/$image:$IMAGE_TAG_TEST" --tag "$PROJECT_REGISTRY/$image:$IMAGE_TAG_PREFIX_TEST$docker_build_commit"
        echo "Retagging $image:$IMAGE_TAG_TEST as $PROJECT_REGISTRY/$image:$IMAGE_TAG_PREFIX$docker_build_commit"
        docker buildx imagetools create "$PROJECT_REGISTRY/$image:$IMAGE_TAG_TEST" --tag "$PROJECT_REGISTRY/$image:$IMAGE_TAG_PREFIX$docker_build_commit"
      done

    # ==== Push commits ====
    - if [ -n "$LOCKFILE_CHANGED" ]; then
    -   echo "Pushing $CI_PROJECT_NAME"
    -   (
    -     cd ./docker-build/
    -     git push -o ci.skip
    -     'echo "Made commit at: $CI_PROJECT_URL/-/commit/$(git rev-parse HEAD)"'
    -   )
    - fi

    - echo "Pushing $FOSS_PROJECT"
    - git push
    - 'echo "Made commit at: $CI_SERVER_URL/$FOSS_PROJECT/-/commit/$(git rev-parse HEAD)"'
