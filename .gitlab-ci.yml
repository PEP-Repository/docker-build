stages:
  - check-existing
  - docker-image
  - generate-lockfile
  - conan-install
  - test-images
  - deploy

variables:
  DOCKER_DRIVER: overlay2 # faster docker builds, see https://gitlab.com/gitlab-org/gitlab-ce/issues/21374, https://docs.docker.com/storage/storagedriver/overlayfs-driver/
  DOCKER_TLS_CERTDIR: "" # Work around failing CI jobs: see https://gitlab.com/gitlab-org/gitlab-ce/issues/64959#note_194582424
  FF_SCRIPT_SECTIONS: 'true'  # Enable collapsible sections per script line, with timings

  PROJECT_REGISTRY: $CI_REGISTRY/$CI_PROJECT_PATH
  IMAGE_TAG_PREFIX: sha-
  IMAGE_TAG: $IMAGE_TAG_PREFIX$CI_COMMIT_SHA
  IMAGE_TAG_TEST: test-$IMAGE_TAG_PREFIX$CI_PIPELINE_ID-$CI_COMMIT_SHA

  FOSS_PROJECT: pep/core
  FOSS_REF:
    value: $CI_COMMIT_REF_NAME
    description: Override to set branch/ref of the PEP FOSS repo to test images on & commit to (for a branch)

  IMAGE_MAX_AGE_DAYS:
    value: '6'
    description:
      If the previous image for a commit is at least this old, it will be rebuilt.
      Set to 0 to force rebuild

  UPDATE_LOCKFILE:
    value: 'branches only'
    options:
      - 'branches only'  # Only for branch pipelines
      - 'no'
    description: Update conan-ci.lock
  TEST_BEFORE_DEPLOY:
    value: necessary
    options:
      - necessary  # Only for protected refs and scheduled pipelines
      - always
      - never
    description: Run test-images
  UPDATE_FOSS:
    value: 'branches only'
    options:
      - 'branches only'  # Only when $FOSS_REF is a branch
      - 'no'
    description: Commit docker-build submodule to PEP FOSS

  # This is a YAML space-separated string, equivalent to >-, see https://yaml-multiline.info/
  # Images that we push in this pipeline
  DEPLOY_IMAGES:
    builder-ubuntu-2204
    builder-ubuntu-rolling
    builder-flatpak
    runtime-ubuntu-2204

# Applies to whole pipeline
workflow:
  rules:
    # Do not create MR pipelines (see https://docs.gitlab.com/ee/ci/pipelines/merge_request_pipelines.html ).
    # As soon as we use one `rules:` tag in a job, that job would run on any MR pipeline, unless specified otherwise.
    # Prevent that by disabling the whole pipeline in this case
    - if: $CI_PIPELINE_SOURCE != 'merge_request_event'

#language=sh
.script_header: &script_header |
  set -u
  bold() {
    # Bold underlined cyan
    IFS=' ' printf "\e[1;4;96m%s\e[0m\n" "$*"
  }
  warn() {
    # Yellow
    IFS=' ' printf "\e[33m%s\e[0m\n" "$*"
  }

#language=sh
.docker_login: &docker_login
  docker login -u gitlab-ci-token -p "$CI_JOB_TOKEN" "$CI_REGISTRY"
#language=sh
.git_colors: &git_colors
  git config --global color.ui always

# You can set a tag `limit_concurrency:<VALUE>` on a gitlab runner if it runs out of memory.
# Jobs can invoke this anchor to retrieve the configured <VALUE> (if any) into the "concurrency_limit" variable.
#language=sh
.set_concurrency_limit: &set_concurrency_limit |
  apk add --no-cache jq
  concurrency_limit=$(echo "$CI_RUNNER_TAGS" | jq -r '.[]' | sed -n 's/^limit_concurrency:\([0-9]\+\)$/\1/p')
  if [ -z "$concurrency_limit" ]; then
    echo 'No concurrency limit specified'
  else
    echo "Concurrency limit is $concurrency_limit"
  fi


# =================================
# ==== Check for recent images ====
# =================================

# Check for recent existing images for this commit.
# We only reuse image if *all* images were recent enough,
# as to keep logic simpler and keep apt dependencies consistent.
# Normally, due to the retagging step, it will be the case anyway that either all or no images were recent.
# Set $REUSE_IMAGES if all images were recent enough
check-existing:
  stage: check-existing
  rules:
    # Quick exit if we force rebuild
    - if: $IMAGE_MAX_AGE_DAYS != '0'
  tags:
    - docker-small
  image: docker
  #language=sh
  script:
    - *script_header
    - touch "$CI_PROJECT_DIR/env.env"
    - apk add --no-cache jq coreutils  # Also add coreutils for `date` (Alpine/busybox date doesn't parse ISO-8601 well)
    - *docker_login
    - reuse=yes
    - for image_name in $DEPLOY_IMAGES; do
    -   echo "Checking $image_name"
    -   prev_created="$(docker buildx imagetools inspect "$PROJECT_REGISTRY/$image_name:$IMAGE_TAG" --format '{{json .Image}}' | jq --raw-output .created || true)"
    -   if [ -n "$prev_created" ]; then
    -     diff_secs="$(($(date +%s) - $(date -d "$prev_created" +%s)))"
    -     diff_days="$((diff_secs / 60 / 60 / 24))"
    -     echo "Previous image created at $prev_created, $diff_days days ($diff_secs s) ago"
    -     if [ "$diff_days" -lt "$IMAGE_MAX_AGE_DAYS" ]; then
    -       echo 'Recent enough'
    -     else
    -       echo 'Not recent enough'
    -       reuse=''
    -       break
    -     fi
    -   else
    -     echo 'No existing image for this commit'
    -     reuse=''
    -     break
    -   fi
    - done

    - if [ -n "$reuse" ]; then
    -   bold 'Will reuse all images'
    -   echo 'REUSE_IMAGES=yes' >>"$CI_PROJECT_DIR/env.env"  # Save, see artifacts
    - else
    -   bold 'Will rebuild all images'
    - fi
  artifacts:
    reports:
      # Save $REUSE_IMAGES for jobs below
      dotenv: env.env

# Skip the rest of this image building job if we are reusing images.
# A better way to skip jobs is not yet available, see https://gitlab.com/gitlab-org/gitlab/-/issues/292816, https://gitlab.com/gitlab-org/gitlab/-/issues/329217
# $REUSE_IMAGES is retrieved from check-existing via env.env
#language=sh
.reuse_images: &reuse_images |
  if [ -n "${REUSE_IMAGES:-}" ]; then
    warn "Images were recent enough, won't rebuild"
    exit
  fi


# ===========================
# ==== Build base images ====
# ===========================
# Here we build the Linux runtime image and the builder images,
# but do not add Conan packages yet, as we first want to update the lockfile,
# for which we need all images.
# We tag the images using $IMAGE_TAG_TEST at first,
# such that they will not overwrite existing images for protected branches
# before we tested them.
# This is skipped if we are reusing images

# Build & push Docker image
.docker-image:
  stage: docker-image
  tags:
    - docker-small
  image: docker
  variables:
    CONTAINER_IMAGE: $PROJECT_REGISTRY/$IMAGE_KIND-$IMAGE_NAME:$IMAGE_TAG_TEST
  services:
    - docker:dind
  before_script:
    - *script_header
    - *reuse_images
  #language=sh
  script:
    - *docker_login
    - bold '==== Building & pushing image ===='
    - echo "Tagging image as $CONTAINER_IMAGE"
    - docker buildx build
      --pull
      --push
      --file "./$IMAGE_KIND/$IMAGE_NAME.Dockerfile"
      --tag "$CONTAINER_IMAGE"
      "./$IMAGE_KIND/"

builder/base/ubuntu-2204:
  extends: .docker-image
  variables:
    IMAGE_KIND: builder
    IMAGE_NAME: ubuntu-2204

builder/base/ubuntu-rolling:
  extends: .docker-image
  variables:
    IMAGE_KIND: builder
    IMAGE_NAME: ubuntu-rolling

builder/base/flatpak:
  extends: .docker-image
  variables:
    IMAGE_KIND: builder
    IMAGE_NAME: flatpak

runtime/ubuntu-2204:
  extends: .docker-image
  variables:
    IMAGE_KIND: runtime
    IMAGE_NAME: ubuntu-2204


# ===========================
# ==== Generate lockfile ====
# ===========================
# We generate a Conan lockfile on each platform for Release & Debug configurations and merge all of them.
# This is because settings etc. can cause different dependencies to be pulled,
# e.g. Windows may require `strawberryperl` while Linux uses perl from the system.
# See https://docs.conan.io/2/tutorial/versioning/lockfiles.html.
# This is skipped if we are reusing images

.generate-lockfile:
  stage: generate-lockfile
  rules:
    - if: $UPDATE_LOCKFILE == 'branches only' && $CI_COMMIT_BRANCH
  variables:
    IMAGE_KIND: builder
    CLICOLOR_FORCE: '1'  # Colored output for Conan
  before_script:
    - *script_header
    - *reuse_images
  # This script must work with both bash and powershell
  #language=sh
  script:
    - cd "./$IMAGE_KIND/conan/"
    # Create Release & Debug lockfile and merge them
    - conan lock create ./ --update
      --profile:all=./conan_profile
      --lockfile=''
      --lockfile-out=./conan-rel.lock
      -s build_type=Release
      -o "&:with_client=True"
      -o "&:with_tests=True"
      -o "&:with_benchmark=True"
      -o "&:use_system_qt=False"
    - conan lock create ./ --update
      --profile:all=./conan_profile
      --lockfile=''
      --lockfile-out=./conan-dbg.lock
      -s "&:build_type=Debug"
      -o "&:with_client=True"
      -o "&:with_tests=True"
      -o "&:with_benchmark=True"
      -o "&:use_system_qt=False"
    - conan lock merge
      --lockfile=./conan-rel.lock
      --lockfile=./conan-dbg.lock
      --lockfile-out="./conan.$name.lock"
  artifacts:
    paths:
      - ./$IMAGE_KIND/conan/conan.$name.lock

.generate-lockfile-docker:
  extends: .generate-lockfile
  tags:
    - docker-small
  image: $PROJECT_REGISTRY/builder-$name:$IMAGE_TAG_TEST

builder/lockfile/ubuntu-2204:
  extends: .generate-lockfile-docker
  needs:
    - builder/base/ubuntu-2204
  variables:
    name: ubuntu-2204

builder/lockfile/ubuntu-rolling:
  extends: .generate-lockfile-docker
  needs:
    - builder/base/ubuntu-rolling
  variables:
    name: ubuntu-rolling

builder/lockfile/windows:
  extends: .generate-lockfile
  needs: []
  tags:
    - windows
  variables:
    name: windows
  # Override
  #language=powershell
  before_script:
    - Set-StrictMode -Version 3.0
    - |
      if ((Test-Path variable:REUSE_IMAGES) -and $REUSE_IMAGES) {
        Write-Host -ForegroundColor Yellow "Images were recent enough, won't rebuild"
        exit
      }

builder/lockfile/macos-arm:
  extends: .generate-lockfile
  needs: []
  tags:
    - macos-arm
  variables:
    name: macos-arm

builder/lockfile/macos-x86:
  extends: .generate-lockfile
  needs: []
  tags:
    - macos-x86
  variables:
    name: macos-x86

# Merge all generated lockfiles.
# Currently, we don't incorporate the Flatpak here because it should generally be identical to Ubuntu LTS
merge-lockfiles:
  stage: generate-lockfile
  needs:
    - builder/lockfile/ubuntu-2204
    - builder/lockfile/ubuntu-rolling
    - builder/lockfile/windows
    - builder/lockfile/macos-arm
    - builder/lockfile/macos-x86
  rules:
    - if: $UPDATE_LOCKFILE == 'branches only' && $CI_COMMIT_BRANCH
  variables:
    IMAGE_KIND: builder
  tags:
    - docker-small
  image: $PROJECT_REGISTRY/builder-ubuntu-2204:$IMAGE_TAG_TEST
  before_script:
    - *script_header
    - *reuse_images
  #language=bash
  script:
    - echo "MERGE_LOCKFILES_JOB=$CI_JOB_ID" >>"$CI_PROJECT_DIR/env.env"  # Save, see artifacts
    - *git_colors
    - cd "./$IMAGE_KIND/conan/"
    - jobs=(
        ubuntu-2204
        ubuntu-rolling
        windows
        macos-arm
        macos-x86
      )
    - |
      merge_flags=()
      for name in "${jobs[@]}"; do
        merge_flags+=("--lockfile=./conan.$name.lock")
      done
    # We don't call this file conan.lock, such that it won't be picked up automatically
    # when running conan with this conanfile (and not a symlink).
    # We don't necessarily want to always use the lockfile on devboxes
    - conan lock merge "${merge_flags[@]}" --lockfile-out=./conan-ci.lock
    # Also make git diff work for new files
    - git add --intent-to-add ./conan-ci.lock
    # `&& true` prevents quitting the shell
    - |
      git diff --exit-code ./conan-ci.lock && true
      case "$?" in
        0) bold 'conan-ci.lock did not change' ;;
        1) 
          bold 'conan-ci.lock changed'
          echo 'LOCKFILE_CHANGED=yes' >>"$CI_PROJECT_DIR/env.env"  # Save if changed, see artifacts
          ;;
        *) exit "$?" ;;
      esac
    # Also put lockfile in root artifact directory for easy access, e.g. from PEP FOSS (via $MERGE_LOCKFILES_JOB)
    - cp ./conan-ci.lock "$CI_PROJECT_DIR"
  artifacts:
    paths:
      - ./$IMAGE_KIND/conan/conan-ci.lock
      - ./conan-ci.lock
    reports:
      # Save $MERGE_LOCKFILES_JOB, $LOCKFILE_CHANGED for jobs below
      dotenv: env.env


# =========================================
# ==== Install dependencies with Conan ====
# =========================================
# Pull the images that we built in the docker-image stage and
# use the lockfile we just generated to install Conan dependencies in the containers (and Flatpak in a container).
# Finally, push the updated containers under the same tag.
# This is skipped if we are reusing images

.conan-builder:
  stage: conan-install
  dependencies:
    - merge-lockfiles
  tags:
    - docker
  image: docker
  variables:
    IMAGE_KIND: builder
    CONTAINER_IMAGE: $PROJECT_REGISTRY/$IMAGE_KIND-$IMAGE_NAME:$IMAGE_TAG_TEST
  services:
    - docker:dind
  before_script:
    - *script_header
    - *reuse_images
  #language=sh
  script:
    - *set_concurrency_limit
    - *docker_login
    - bold '==== Executing Conan in container ===='
    - container="$(docker container run --pull=always --interactive --detach "$CONTAINER_IMAGE")"
    - if [ -d "./$IMAGE_KIND/cache/conan-home/" ]; then
    -   echo 'Copying cached .conan2 folder'
    -   docker container cp "./$IMAGE_KIND/cache/conan-home/" "$container:/root/.conan2/"
    - fi
    - docker container cp ."/$IMAGE_KIND/conan/" "$container:/tmp/conan"
    - docker container exec "$container" /tmp/conan/conan_install.sh "$concurrency_limit"
    - docker container exec "$container" rm -rf '/tmp/*'
    - rm -rf "./$IMAGE_KIND/cache/conan-home/"
    - mkdir -p "./$IMAGE_KIND/cache/"
    - docker container cp "$container:/root/.conan2/" "./$IMAGE_KIND/cache/conan-home"
    - docker container stop "$container"
    - docker container commit --message 'Add Conan packages' "$container" "$CONTAINER_IMAGE"

    - bold '==== Pushing image ===='
    - docker push "$CONTAINER_IMAGE"
  cache:
    key: docker-builder-cache
    paths:
      - ./$IMAGE_KIND/cache/

builder/ubuntu-2204:
  extends: .conan-builder
  variables:
    IMAGE_NAME: ubuntu-2204

builder/ubuntu-rolling:
  extends: .conan-builder
  variables:
    IMAGE_NAME: ubuntu-rolling

builder/flatpak:
  stage: conan-install
  # We need both the image with flatpak-builder and the lockfile
  needs:
    - builder/base/flatpak
  rules:
    - if: $UPDATE_LOCKFILE == 'branches only' && $CI_COMMIT_BRANCH
      needs:
        - builder/base/flatpak
        - merge-lockfiles
    - when: on_success
  tags:
    - docker
  image: docker
  variables:
    IMAGE_KIND: builder
    IMAGE_NAME: flatpak
    CONTAINER_IMAGE: $PROJECT_REGISTRY/$IMAGE_KIND-$IMAGE_NAME:$IMAGE_TAG_TEST
  services:
    - docker:dind
  before_script:
    - *script_header
    - *reuse_images
  #language=sh
  script:
    - *set_concurrency_limit
    - *docker_login
    - bold '==== Executing Flatpak Builder with Conan in container ===='
    # --privileged is necessary for flatpak-builder, see https://github.com/flatpak/flatpak-builder/issues/237
    - container="$(docker container run --pull=always --privileged --interactive --detach "$CONTAINER_IMAGE")"
    #TODO Cache ~/.conan2 like above?
    - docker container cp "./$IMAGE_KIND/flatpak/" "$container:/tmp/flatpak"
    - docker container cp "./$IMAGE_KIND/conan/" "$container:/tmp/conan"
    - |
      concurrency_option=''
      if [ -n "$concurrency_limit" ]; then
        concurrency_option="--jobs=$concurrency_limit"
      fi
    # Generate base image for nl.ru.cs.pep.client.yml and save as /pep-base.flatpak
    - docker container exec "$container" flatpak-builder $concurrency_option --repo /tmp/flatpak/repo /tmp/flatpak/build /tmp/flatpak/nl.ru.cs.pep.base.yml
    - docker container exec "$container" flatpak build-bundle /tmp/flatpak/repo /pep-base.flatpak nl.ru.cs.pep.base --runtime-repo=https://flathub.org/repo/flathub.flatpakrepo
    - docker container exec "$container" rm -rf '/tmp/*'
    - docker container stop "$container"
    - docker container commit --message 'Build base flatpak with Conan packages' "$container" "$CONTAINER_IMAGE"

    - bold '==== Pushing image ===='
    - docker push "$CONTAINER_IMAGE"


# =====================
# ==== Test images ====
# =====================
# Test if PEP FOSS still builds with the images we just built:
# start a pipeline in the FOSS repo that overrides the docker-build version
# and forwards the updated lockfile
test-images:
  stage: test-images
  rules:
    - if:
        $TEST_BEFORE_DEPLOY == 'always' ||
        (
          $TEST_BEFORE_DEPLOY == 'necessary' &&
          ($CI_COMMIT_REF_PROTECTED == 'true' || $CI_PIPELINE_SOURCE == 'schedule')
        )
    - when: manual
      allow_failure: true  # Make sure that the pipeline still continues
  tags:
    - docker-small
  image: alpine
  #language=sh
  script:
    - *script_header
    # We don't check $REUSE_IMAGES here, because we want to make sure that when a commit is added to a different branch,
    #  we run a pipeline in PEP FOSS in the corresponding branch
    - apk add --no-cache jq curl
    # $MERGE_LOCKFILES_JOB may not be set if $UPDATE_LOCKFILE is false
    - ./run-pipeline.sh "$IMAGE_TAG_TEST" "$FOSS_REF" "${MERGE_LOCKFILES_JOB:-}"


# ================
# ==== Deploy ====
# ================
# If lockfile was updated:
# - Make commit in docker-build
# - Retag test images for that commit
# - If $UPDATE_FOSS: Update submodule & RUNNER_IMAGE_TAG in $FOSS_REF to that commit
# If lockfile wasn't updated:
# - Retag test images for our commit
deploy:
  stage: deploy
  dependencies:
    - merge-lockfiles
  # Redundant with script below, but skip creating this job when there cannot be anything to commit
  rules:
    - if: ($UPDATE_LOCKFILE == 'branches only' && $CI_COMMIT_BRANCH) || $UPDATE_FOSS != 'no'
  tags:
    - docker-small
  image: docker
  variables:
    GIT_STRATEGY: none  # Do not fetch nor clean working tree
  #language=sh
  script:
    - *script_header

    - if [ -n "${LOCKFILE_CHANGED:-}" ]; then
    -   |
        bold 'Lockfile was changed, so we cannot retag the built images for this commit'
        bold "Hence we need to update $CI_PROJECT_NAME, and retag images for the new commit"
    - elif [ -n "${REUSE_IMAGES:-}" ]; then
    -   warn "Images were recent enough, don't need to retag"
    - else
    -   bold 'Retagging test images just built for this commit'
    -   *docker_login
    -   |
        for image in $DEPLOY_IMAGES; do
          echo "Retagging $image:$IMAGE_TAG_TEST as $PROJECT_REGISTRY/$image:$IMAGE_TAG"
          docker buildx imagetools create "$PROJECT_REGISTRY/$image:$IMAGE_TAG_TEST" --tag "$PROJECT_REGISTRY/$image:$IMAGE_TAG"
        done
    - fi

    - |
      if [ -z "${LOCKFILE_CHANGED:-}" -a "$UPDATE_FOSS" = no ]; then
        warn "Won't commit anything, lockfile did not change and UPDATE_FOSS is false"
        exit
      fi

    # ==== Clone docker-build, and PEP FOSS repo if necessary (with docker-build as submodule) ====
    - apk add --no-cache git
    - *git_colors
    # Do not put token in the URL to prevent it from being printed on clone
    - |
      cat >./git-password.sh <<'EOF'
      #!/usr/bin/env sh
      exec echo "$GITLAB_ACCESS_TOKEN"
      EOF
      chmod +x ./git-password.sh
      git config --global core.askPass "$PWD/git-password.sh"
    - |
      git config --global user.email support@pep.cs.ru.nl
      git config --global user.name "Gitlab CI script from $CI_PROJECT_NAME"

    - if [ "$UPDATE_FOSS" != no ]; then
    -   bold "Cloning $FOSS_PROJECT and $CI_PROJECT_NAME"
    #   --sparse: Sparse checkout: do not checkout all subdirectories on the disk
    #   --depth=1: Shallow clone: do not fetch history
    #   This requires $FOSS_REF to exist
    -   git clone
        --branch="$FOSS_REF"
        --sparse
        --no-tags
        --depth=1
        --shallow-submodules
        --recurse-submodules=docker-build
        "$CI_SERVER_URL/$FOSS_PROJECT.git" ./pep
    -   foss_repo="$CI_PROJECT_DIR/pep"
    -   docker_build_repo="$foss_repo/docker-build"
    - else
    -   bold "Cloning only $CI_PROJECT_NAME"
    -   git clone
        --branch="$CI_COMMIT_BRANCH"
        --no-tags
        --depth=1
        "$CI_PROJECT_URL.git" ./docker-build
    -   docker_build_repo="$CI_PROJECT_DIR/docker-build"
    - fi

    # ==== Update docker-build submodule ====
    - bold "Updating $CI_PROJECT_NAME"
    - cd "$docker_build_repo"
    #TODO make work with non-branches
    # By default, submodule has only main branch
    - git remote set-branches origin "$CI_COMMIT_BRANCH"
    - git fetch origin "$CI_COMMIT_BRANCH"
    # Checkout our branch
    - git switch "$CI_COMMIT_BRANCH"
    # Is the commit SHA from this pipeline the tip of our branch?
    - |
      tip="$(git rev-parse HEAD)"
      if [ "$tip" != "$CI_COMMIT_SHA" ]; then
        >&2 warn "This ($CI_COMMIT_SHA) is not the latest $CI_PROJECT_NAME commit for $CI_COMMIT_BRANCH, that is $tip"
        exit 1
      fi
    - if [ -n "${LOCKFILE_CHANGED:-}" ]; then
    -   bold "Committing lockfile in $CI_PROJECT_NAME"
    -   mv --force "$CI_PROJECT_DIR/conan-ci.lock" ./builder/conan/
    -   git add .; git status
    -   |
        git commit -m "Update conan-ci.lock for pipeline $CI_PIPELINE_ID
        $CI_JOB_URL"
    - fi
    - docker_build_commit="$(git rev-parse HEAD)"
    - cd "$CI_PROJECT_DIR"
    - new_image_tag="$IMAGE_TAG_PREFIX$docker_build_commit"

    # ==== Update PEP FOSS repo ====
    - updated_foss=''
    - if [ "$UPDATE_FOSS" != no ]; then
    -   cd "$foss_repo"
    #   $FOSS_REF exists, but is it a branch?
    -   if ! git show-ref --heads "$FOSS_REF"; then
    -     warn "$FOSS_PROJECT $FOSS_REF is not a branch, will not update FOSS repo"
    -   else
    -       bold "Committing in $FOSS_PROJECT"
    #       We just updated the submodule, now update the image tag as well
    -       git sparse-checkout add ci_cd/
    -       runner_image_yml=./ci_cd/docker-common.yml
    -       sed --in-place "s/\(RUNNER_IMAGE_TAG:\s*\)\S*/\1$new_image_tag/" "$runner_image_yml"
    #       Make sure sed actually matched something
    -       |
            if ! grep -q "RUNNER_IMAGE_TAG:\s*$new_image_tag" "$runner_image_yml"; then
              >&2 warn "Failed to update $runner_image_yml in $FOSS_PROJECT"
              exit 1
            fi
    #     Did we update docker-build (via checkout / lockfile commit) or the RUNNER_IMAGE_TAG?
    #     Or was PEP FOSS already up-to-date?
    -     |
          git diff && true
          case "$?" in
            0) # No differences
              bold "$FOSS_PROJECT was already up-to-date"
              foss_up_to_date=yes
              ;;
            1) foss_up_to_date='' ;;
            *) exit "$?" ;;
          esac
    -     if [ -z "$foss_up_to_date" ]; then
    -       git add .; git status
    -       |
            git commit -m "Update docker-build for pipeline $CI_PIPELINE_ID
            $CI_JOB_URL"
    -       updated_foss=yes
    -     fi
    -   fi
    -   foss_commit="$(git rev-parse HEAD)"
    -   cd "$CI_PROJECT_DIR"
    - fi

    # ==== Retag built images for created docker-build commit ====
    - if [ -n "${LOCKFILE_CHANGED:-}" ]; then
    -   bold "Retagging images just built as those for the new $CI_PROJECT_NAME commit ($docker_build_commit)"
    -   *docker_login
    -   |
        for image in $DEPLOY_IMAGES; do
          echo "Retagging $image:$IMAGE_TAG_TEST as $PROJECT_REGISTRY/$image:$new_image_tag"
          docker buildx imagetools create "$PROJECT_REGISTRY/$image:$IMAGE_TAG_TEST" --tag "$PROJECT_REGISTRY/$image:$new_image_tag"
        done
    - fi

    # ==== Push commits ====
    - if [ -n "${LOCKFILE_CHANGED:-}" ]; then
    -   bold "Pushing $CI_PROJECT_NAME"
    -   (
    -     cd "$docker_build_repo"
    -     git push -o ci.skip
    -     'bold "Made commit at: $CI_PROJECT_URL/-/commit/$docker_build_commit"'
    -   )
    - fi

    - if [ -n "$updated_foss" ]; then
    -   (
    -     cd "$foss_repo"
    -     bold "Pushing $FOSS_PROJECT"
          # The pipeline triggered by this should terminate with the same status as the test pipeline (if we ran one above)
    -     git push
    -     'bold "Made commit at: $CI_SERVER_URL/$FOSS_PROJECT/-/commit/$foss_commit"'
    -   )
    - fi
