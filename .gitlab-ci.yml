stages:
  - docker-image
  - generate-lockfile
  - conan-install
  - analyze
  - deploy
  - analyze-manual

variables:
  DOCKER_DRIVER: overlay2 # faster docker builds, see https://gitlab.com/gitlab-org/gitlab-ce/issues/21374, https://docs.docker.com/storage/storagedriver/overlayfs-driver/
  DOCKER_TLS_CERTDIR: "" # Work around failing CI jobs: see https://gitlab.com/gitlab-org/gitlab-ce/issues/64959#note_194582424
  FF_SCRIPT_SECTIONS: 'true'  # Enable collapsible sections per script line, with timings

  PROJECT_REGISTRY: ${CI_REGISTRY}/${CI_PROJECT_PATH}
  IMAGE_TAG: sha-${CI_COMMIT_SHA}
  IMAGE_TAG_TEST: sha-test-${CI_COMMIT_SHA}

  # Override to set branch/ref of pep/core to test images on
  CORE_TEST_REF: ${CI_COMMIT_BRANCH}

  # >- is a YAML space-separated string, see https://yaml-multiline.info/
  # Images that should be retagged from $IMAGE_TAG_TEST to $IMAGE_TAG
  DEPLOY_IMAGES: >-
    builder-ubuntu-2204
    builder-ubuntu-rolling
    builder-flatpak
    runtime-ubuntu-2204
  # Branches update pipelines are scheduled on, in regex form
  SCHEDULE_BRANCHES_REGEX: ^(master|stable|release)$
  # If the previous image for a commit is at least this old, it will be rebuilt
  IMAGE_MAX_AGE_DAYS: 6

# You can set a tag `limit_concurrency:<VALUE>` on a gitlab runner if it runs out of memory.
# Jobs can invoke this anchor to retrieve the configured <VALUE> (if any) into the "concurrency_limit" variable.
.set_concurrency_limit: &set_concurrency_limit |
  apk add --no-cache jq
  concurrency_limit=$(echo "$CI_RUNNER_TAGS" | jq -r '.[]' | sed -n 's/^limit_concurrency:\([0-9]\+\)$/\1/p')
  if [ -z "$concurrency_limit" ]; then
    >&2 echo "No concurrency limit specified"
  else
    >&2 echo "Concurrency limit is $concurrency_limit"
  fi


# Build & push Docker image
.docker-image:
  stage: docker-image
  tags:
    - docker-small
  image: docker
  variables:
    CONTAINER_IMAGE: ${PROJECT_REGISTRY}/${IMAGE_KIND}-${IMAGE_NAME}:${IMAGE_TAG_TEST}
  services:
    - docker:dind
  before_script:
    - apk add --no-cache jq coreutils  # Also add coreutils for `date` (Alpine/busybox date doesn't parse ISO-8601 well)
    - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
    - touch env.env
    - |
      prev_created=$(docker buildx imagetools inspect ${PROJECT_REGISTRY}/${IMAGE_KIND}-${IMAGE_NAME}:${IMAGE_TAG} --format '{{json .Image}}' | jq --raw-output .created || true)
      if [ -n "$prev_created" ]; then
        diff_secs=$(($(date +%s) - $(date -d "$prev_created" +%s)))
        diff_days=$((diff_secs / 60 / 60 / 24))
        echo "Previous image created at $prev_created, $diff_days days ($diff_secs s) ago"
        if [ "$diff_days" -lt "${IMAGE_MAX_AGE_DAYS}" ]; then
          echo "Recent enough, won't rebuild"
          exit
        else
          echo 'Not recent enough, will rebuild'
        fi
      else
        echo 'No existing image for this commit'
      fi
      echo 'NEW_IMAGE=1' >>env.env  # Save, see artifacts
    - echo "Tagging image as $CONTAINER_IMAGE"
  script:
    - echo '==== Building & pushing image ===='
    - >
      docker buildx build
      --pull
      --push
      --file ./${IMAGE_KIND}/${IMAGE_NAME}.Dockerfile
      --tag ${CONTAINER_IMAGE}
      ${DOCKER_ARGS}
      ./${IMAGE_KIND}/
  artifacts:
    reports:
      # Save $NEW_IMAGE for jobs below
      dotenv: env.env

builder/base/ubuntu-2204:
  extends: .docker-image
  variables:
    IMAGE_KIND: builder
    IMAGE_NAME: ubuntu-2204

builder/base/ubuntu-rolling:
  extends: .docker-image
  variables:
    IMAGE_KIND: builder
    IMAGE_NAME: ubuntu-rolling

builder/base/flatpak:
  extends: .docker-image
  variables:
    IMAGE_KIND: builder
    IMAGE_NAME: flatpak

runtime/ubuntu-2204:
  extends: .docker-image
  variables:
    IMAGE_KIND: runtime
    IMAGE_NAME: ubuntu-2204

####
.generate-lockfile:
  stage: generate-lockfile
  variables:
    IMAGE_KIND: builder
    CLICOLOR_FORCE: '1'  # Colored output for Conan
  # This script must work with both bash and powershell
  script:
    - cd ./${IMAGE_KIND}/conan/
    - >
      conan lock create ./ --update
      --profile:all=./conan_profile
      --lockfile=''
      --lockfile-out=./conan-rel.lock
      -s build_type=Release
      -o with_client=True
      -o with_tests=True
      -o with_benchmark=True
    - >
      conan lock create ./ --update
      --profile:all=./conan_profile
      --lockfile=''
      --lockfile-out=./conan-dbg.lock
      -s build_type=Debug
      -o with_client=True
      -o with_tests=True
      -o with_benchmark=True
    - >
      conan lock merge
      --lockfile=./conan-rel.lock
      --lockfile=./conan-dbg.lock
      --lockfile-out=./conan.${name}.lock
  artifacts:
    paths:
      - ./${IMAGE_KIND}/conan/conan.${name}.lock

.generate-lockfile-docker:
  extends: .generate-lockfile
  tags:
    - docker-small
  image: ${PROJECT_REGISTRY}/builder-${name}:${IMAGE_TAG_TEST}

builder/lockfile/ubuntu-2204:
  extends: .generate-lockfile-docker
  needs:
    - builder/base/ubuntu-2204
  variables:
    name: ubuntu-2204

builder/lockfile/ubuntu-rolling:
  extends: .generate-lockfile-docker
  needs:
    - builder/base/ubuntu-rolling
  variables:
    name: ubuntu-rolling

builder/lockfile/windows:
  extends: .generate-lockfile
  needs: []
  tags:
    - windows
  variables:
    name: windows

builder/lockfile/macos-arm:
  extends: .generate-lockfile
  needs: []
  tags:
    - macos-arm
  variables:
    name: macos-arm

builder/lockfile/macos-x86:
  extends: .generate-lockfile
  needs: []
  tags:
    - macos-x86
  variables:
    name: macos-x86

#TODO flatpak?
merge-lockfiles:
  stage: generate-lockfile
  needs:
    - builder/lockfile/ubuntu-2204
    - builder/lockfile/ubuntu-rolling
    - builder/lockfile/windows
    - builder/lockfile/macos-arm
    - builder/lockfile/macos-x86
  variables:
    IMAGE_KIND: builder
  tags:
    - docker-small
  # Any Conan image
  image: ${PROJECT_REGISTRY}/builder-ubuntu-rolling:${IMAGE_TAG_TEST}
  script:
    - echo "MERGE_LOCKFILES_JOB=${CI_JOB_ID}" >>env.env  # Save, see artifacts
    - cd ./${IMAGE_KIND}/conan/
    - jobs=(
        ubuntu-2204
        ubuntu-rolling
        windows
        macos-arm
        macos-x86
      )
    - |
      merge_flags=()
      for name in $jobs; do
        merge_flags+="--lockfile=./conan.$name.lock"
      done
    # Generate conan.lock
    - conan lock merge "${merge_flags[@]}"
    - cp ./conan.lock ../../
  artifacts:
    paths:
      - ./${IMAGE_KIND}/conan/conan.lock
      - ./conan.lock
    reports:
      # Save $MERGE_LOCKFILES_JOB for jobs below
      dotenv: env.env

####
.conan-builder:
  stage: conan-install
  needs:
    - merge-lockfiles
  tags:
    - docker
  image: docker
  variables:
    IMAGE_KIND: builder
    CONTAINER_IMAGE: ${PROJECT_REGISTRY}/${IMAGE_KIND}-${IMAGE_NAME}:${IMAGE_TAG_TEST}
  services:
    - docker:dind
  script:
    - *set_concurrency_limit
    - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
    - echo '==== Executing Conan in container ===='
    - container="$(docker container run --interactive --detach ${CONTAINER_IMAGE})"
    - |
      if [ -d ./${IMAGE_KIND}/cache/conan-home/ ]; then
        echo 'Copying cached .conan2 folder'
        docker cp ./${IMAGE_KIND}/cache/conan-home/ "$container:/root/.conan2/"
      fi
    - docker container cp ./${IMAGE_KIND}/conan/ "$container:/tmp/conan"
    - docker container exec "$container" /tmp/conan/conan_install.sh "$concurrency_limit"
    - docker container exec "$container" rm -rf '/tmp/*'
    - rm -rf ./${IMAGE_KIND}/cache/conan-home/
    - mkdir -p ./${IMAGE_KIND}/cache/
    - docker container cp "$container:/root/.conan2/" ./${IMAGE_KIND}/cache/conan-home
    - docker container stop "$container"
    - docker container commit --message 'Add Conan packages' "$container" ${CONTAINER_IMAGE}

    - echo "==== Pushing image ===="
    - docker push ${CONTAINER_IMAGE}
  cache:
    key: docker-builder-cache
    paths:
      - ./${IMAGE_KIND}/cache/

builder/ubuntu-2204:
  extends: .conan-builder
  variables:
    IMAGE_NAME: ubuntu-2204

builder/ubuntu-rolling:
  extends: .conan-builder
  variables:
    IMAGE_NAME: ubuntu-rolling

builder/flatpak:
  stage: conan-install
  needs:
    - merge-lockfiles
  tags:
    - docker
  image: docker
  variables:
    IMAGE_KIND: builder
    IMAGE_NAME: flatpak
    CONTAINER_IMAGE: ${PROJECT_REGISTRY}/${IMAGE_KIND}-${IMAGE_NAME}:${IMAGE_TAG_TEST}
  services:
    - docker:dind
  script:
    - *set_concurrency_limit
    - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
    - echo '==== Executing Flatpak Builder with Conan in container ===='
    # --privileged is necessary for flatpak-builder, see https://github.com/flatpak/flatpak-builder/issues/237
    - container="$(docker container run --privileged --interactive --detach ${CONTAINER_IMAGE})"
    #TODO Cache ~/.conan2 like above?
    - docker container cp ./${IMAGE_KIND}/flatpak/ "$container:/tmp/flatpak"
    - docker container cp ./${IMAGE_KIND}/conan/ "$container:/tmp/conan"
    - |
      if [ -n "$concurrency_limit" ]; then
        concurrency_option="--jobs=$concurrency_limit"
      fi
    # Generate base image for nl.ru.cs.pep.client.yml and save as /pep-base.flatpak
    - docker container exec "$container" flatpak-builder $concurrency_option --repo /tmp/flatpak/repo /tmp/flatpak/build /tmp/flatpak/nl.ru.cs.pep.base.yml
    - docker container exec "$container" flatpak build-bundle /tmp/flatpak/repo /pep-base.flatpak nl.ru.cs.pep.base --runtime-repo=https://flathub.org/repo/flathub.flatpakrepo
    - docker container exec "$container" rm -rf '/tmp/*'
    - docker container stop "$container"
    - docker container commit --message 'Build base flatpak with Conan packages' "$container" ${CONTAINER_IMAGE}

    - echo '==== Pushing image ===='
    - docker push ${CONTAINER_IMAGE}

###
test-images:
  stage: analyze
  rules:
    # Only enable on schedule branches, and do not create MR pipelines (see https://docs.gitlab.com/ee/ci/pipelines/merge_request_pipelines.html )
    - if: $CI_COMMIT_BRANCH !~ $SCHEDULE_BRANCHES_REGEX || $CI_PIPELINE_SOURCE == 'merge_request_event'
      when: never
    - when: on_success
  tags:
    - docker-small
  image: alpine
  script:
    - apk add --no-cache jq curl
    - ./run-pipeline.sh ${IMAGE_TAG_TEST} "${CORE_TEST_REF}" "${MERGE_LOCKFILES_JOB}"

test-images-manual:
  stage: analyze-manual
  when: manual
  tags:
    - docker-small
  image: alpine
  script:
    # We don't check $NEW_IMAGE here, because we want to make sure that when a commit is added to a different branch,
    #  we run a pipeline in PEP core in the corresponding branch
    - apk add --no-cache jq curl
    - ./run-pipeline.sh ${IMAGE_TAG} "${CORE_TEST_REF}" "${MERGE_LOCKFILES_JOB}"

###
deploy-images:
  stage: deploy
  tags:
    - docker-small
  image: docker
  services:
    - docker:dind
  script:
    # A better way to skip jobs is not yet available, see https://gitlab.com/gitlab-org/gitlab/-/issues/292816, https://gitlab.com/gitlab-org/gitlab/-/issues/329217
    # $NEW_IMAGE is retrieved from jobs above via env.env
    - if [ "$NEW_IMAGE" != 1 ]; then exit; fi
    - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
    - |
      for image in ${DEPLOY_IMAGES}; do
        echo "Retagging $image:${IMAGE_TAG_TEST} as ${PROJECT_REGISTRY}/$image:${IMAGE_TAG}"
        # This assumes sha-test tags of an image will not be cleaned up if it is still recent and thus reused
        docker buildx imagetools create --tag ${PROJECT_REGISTRY}/$image:${IMAGE_TAG} ${PROJECT_REGISTRY}/$image:${IMAGE_TAG_TEST}
      done
