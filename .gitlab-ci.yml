stages:
  - docker-image
  - generate-lockfile
  - conan-install
  - analyze
  - deploy
  - analyze-manual

variables:
  DOCKER_DRIVER: overlay2 # faster docker builds, see https://gitlab.com/gitlab-org/gitlab-ce/issues/21374, https://docs.docker.com/storage/storagedriver/overlayfs-driver/
  DOCKER_TLS_CERTDIR: "" # Work around failing CI jobs: see https://gitlab.com/gitlab-org/gitlab-ce/issues/64959#note_194582424
  FF_SCRIPT_SECTIONS: 'true'  # Enable collapsible sections per script line, with timings

  PROJECT_REGISTRY: ${CI_REGISTRY}/${CI_PROJECT_PATH}
  IMAGE_TAG: sha-${CI_COMMIT_SHA}
  IMAGE_TAG_TEST: sha-test-${CI_COMMIT_SHA}
  PARENT_IMAGE_TAG: sha-test-${CI_COMMIT_BEFORE_SHA}

  CORE_PROJECT: pep/core
  # Override to set branch/ref of pep/core to test images on
  CORE_TEST_REF: ${CI_COMMIT_BRANCH}

  FORCE_TEST:
    value: ''
    options:
      - ''
      - 'yes'
    description: Always run test-images
  FORCE_UPDATE_CORE:
    value: ''
    options:
      - ''
      - 'yes'
    description: Always update core repository
  RETAG_PARENT_COMMIT_IMAGES:
    value: ''
    options:
      - ''
      - 'yes'
    description: Do not build new images, re-tag the ones from our parent commit instead

  # >- is a YAML space-separated string, see https://yaml-multiline.info/
  # Images that should be retagged from $IMAGE_TAG_TEST to $IMAGE_TAG
  DEPLOY_IMAGES: >-
    builder-ubuntu-2204
    builder-ubuntu-rolling
    builder-flatpak
    runtime-ubuntu-2204
  # Branches update pipelines are scheduled on, in regex form
  SCHEDULE_BRANCHES_REGEX: ^(master|stable|release)$
  # If the previous image for a commit is at least this old, it will be rebuilt
  IMAGE_MAX_AGE_DAYS: 6

.no_mr_pipelines: &no_mr_pipelines
  # Do not create MR pipelines (see https://docs.gitlab.com/ee/ci/pipelines/merge_request_pipelines.html )
  if: $CI_PIPELINE_SOURCE == 'merge_request_event'
  when: never

.not_if_retagging_parent: &not_if_retagging_parent
  if: $RETAG_PARENT_COMMIT_IMAGES
  when: never

.rules_only_when_building: &rules_only_when_building
  rules:
    - *no_mr_pipelines
    - *not_if_retagging_parent
    - when: on_success

# You can set a tag `limit_concurrency:<VALUE>` on a gitlab runner if it runs out of memory.
# Jobs can invoke this anchor to retrieve the configured <VALUE> (if any) into the "concurrency_limit" variable.
.set_concurrency_limit: &set_concurrency_limit |
  apk add --no-cache jq
  concurrency_limit=$(echo "$CI_RUNNER_TAGS" | jq -r '.[]' | sed -n 's/^limit_concurrency:\([0-9]\+\)$/\1/p')
  if [ -z "$concurrency_limit" ]; then
    >&2 echo "No concurrency limit specified"
  else
    >&2 echo "Concurrency limit is $concurrency_limit"
  fi


# Build & push Docker image
.docker-image:
  stage: docker-image
  tags:
    - docker-small
  image: docker
  variables:
    CONTAINER_IMAGE: ${PROJECT_REGISTRY}/${IMAGE_KIND}-${IMAGE_NAME}:${IMAGE_TAG_TEST}
  services:
    - docker:dind
  <<: *rules_only_when_building
  before_script:
    - apk add --no-cache jq coreutils  # Also add coreutils for `date` (Alpine/busybox date doesn't parse ISO-8601 well)
    - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
    - touch env.env
    - |
      prev_created=$(docker buildx imagetools inspect ${PROJECT_REGISTRY}/${IMAGE_KIND}-${IMAGE_NAME}:${IMAGE_TAG} --format '{{json .Image}}' | jq --raw-output .created || true)
      if [ -n "$prev_created" ]; then
        diff_secs=$(($(date +%s) - $(date -d "$prev_created" +%s)))
        diff_days=$((diff_secs / 60 / 60 / 24))
        echo "Previous image created at $prev_created, $diff_days days ($diff_secs s) ago"
        if [ "$diff_days" -lt "${IMAGE_MAX_AGE_DAYS}" ]; then
          echo "Recent enough, won't rebuild"
          exit
        else
          echo 'Not recent enough, will rebuild'
        fi
      else
        echo 'No existing image for this commit'
      fi
      echo 'NEW_IMAGE=yes' >>env.env  # Save, see artifacts
    - echo "Tagging image as $CONTAINER_IMAGE"
  script:
    - echo '==== Building & pushing image ===='
    - >
      docker buildx build
      --pull
      --push
      --file ./${IMAGE_KIND}/${IMAGE_NAME}.Dockerfile
      --tag ${CONTAINER_IMAGE}
      ${DOCKER_ARGS}
      ./${IMAGE_KIND}/
  artifacts:
    reports:
      # Save $NEW_IMAGE for jobs below
      dotenv: env.env

builder/base/ubuntu-2204:
  extends: .docker-image
  variables:
    IMAGE_KIND: builder
    IMAGE_NAME: ubuntu-2204

builder/base/ubuntu-rolling:
  extends: .docker-image
  variables:
    IMAGE_KIND: builder
    IMAGE_NAME: ubuntu-rolling

builder/base/flatpak:
  extends: .docker-image
  variables:
    IMAGE_KIND: builder
    IMAGE_NAME: flatpak

runtime/ubuntu-2204:
  extends: .docker-image
  variables:
    IMAGE_KIND: runtime
    IMAGE_NAME: ubuntu-2204

####
.generate-lockfile:
  stage: generate-lockfile
  variables:
    IMAGE_KIND: builder
    CLICOLOR_FORCE: '1'  # Colored output for Conan
  <<: *rules_only_when_building
  # This script must work with both bash and powershell
  script:
    - cd ./${IMAGE_KIND}/conan/
    - >
      conan lock create ./ --update
      --profile:all=./conan_profile
      --lockfile=''
      --lockfile-out=./conan-rel.lock
      -s build_type=Release
      -o "&:with_client=True"
      -o "&:with_tests=True"
      -o "&:with_benchmark=True"
      -o "&:use_system_qt=False"
    - >
      conan lock create ./ --update
      --profile:all=./conan_profile
      --lockfile=''
      --lockfile-out=./conan-dbg.lock
      -s "&:build_type=Debug"
      -o "&:with_client=True"
      -o "&:with_tests=True"
      -o "&:with_benchmark=True"
      -o "&:use_system_qt=False"
    - >
      conan lock merge
      --lockfile=./conan-rel.lock
      --lockfile=./conan-dbg.lock
      --lockfile-out=./conan.${name}.lock
  artifacts:
    paths:
      - ./${IMAGE_KIND}/conan/conan.${name}.lock

.generate-lockfile-docker:
  extends: .generate-lockfile
  tags:
    - docker-small
  image: ${PROJECT_REGISTRY}/builder-${name}:${IMAGE_TAG_TEST}

builder/lockfile/ubuntu-2204:
  extends: .generate-lockfile-docker
  needs:
    - builder/base/ubuntu-2204
  variables:
    name: ubuntu-2204

builder/lockfile/ubuntu-rolling:
  extends: .generate-lockfile-docker
  needs:
    - builder/base/ubuntu-rolling
  variables:
    name: ubuntu-rolling

builder/lockfile/windows:
  extends: .generate-lockfile
  needs: []
  tags:
    - windows
  variables:
    name: windows

builder/lockfile/macos-arm:
  extends: .generate-lockfile
  needs: []
  tags:
    - macos-arm
  variables:
    name: macos-arm

builder/lockfile/macos-x86:
  extends: .generate-lockfile
  needs: []
  tags:
    - macos-x86
  variables:
    name: macos-x86

# Currently we don't incorporate the Flatpak here because it should generally be identical to Ubuntu LTS
merge-lockfiles:
  stage: generate-lockfile
  needs:
    - builder/lockfile/ubuntu-2204
    - builder/lockfile/ubuntu-rolling
    - builder/lockfile/windows
    - builder/lockfile/macos-arm
    - builder/lockfile/macos-x86
  variables:
    IMAGE_KIND: builder
  tags:
    - docker-small
  image: ${PROJECT_REGISTRY}/builder-ubuntu-2204:${IMAGE_TAG_TEST}
  <<: *rules_only_when_building
  script:
    - echo "MERGE_LOCKFILES_JOB=${CI_JOB_ID}" >>env.env  # Save, see artifacts
    - cd ./${IMAGE_KIND}/conan/
    - jobs=(
        ubuntu-2204
        ubuntu-rolling
        windows
        macos-arm
        macos-x86
      )
    - |
      merge_flags=()
      for name in "${jobs[@]}"; do
        merge_flags+=("--lockfile=./conan.$name.lock")
      done
    # Generate conan.lock
    - conan lock merge "${merge_flags[@]}"
    - git diff --exit-code ./conan.lock ||  echo 'LOCKFILE_CHANGED=yes' >>env.env  # Save, see artifacts
    - cp ./conan.lock ../../
  artifacts:
    paths:
      - ./${IMAGE_KIND}/conan/conan.lock
      - ./conan.lock
    reports:
      # Save $MERGE_LOCKFILES_JOB, $LOCKFILE_CHANGED for jobs below
      dotenv: env.env

####
.conan-builder:
  stage: conan-install
  needs:
    - merge-lockfiles
  tags:
    - docker
  image: docker
  <<: *rules_only_when_building
  variables:
    IMAGE_KIND: builder
    CONTAINER_IMAGE: ${PROJECT_REGISTRY}/${IMAGE_KIND}-${IMAGE_NAME}:${IMAGE_TAG_TEST}
  services:
    - docker:dind
  script:
    - *set_concurrency_limit
    - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
    - echo '==== Executing Conan in container ===='
    - container="$(docker container run --interactive --detach ${CONTAINER_IMAGE})"
    - |
      if [ -d ./${IMAGE_KIND}/cache/conan-home/ ]; then
        echo 'Copying cached .conan2 folder'
        docker cp ./${IMAGE_KIND}/cache/conan-home/ "$container:/root/.conan2/"
      fi
    - docker container cp ./${IMAGE_KIND}/conan/ "$container:/tmp/conan"
    - docker container exec "$container" /tmp/conan/conan_install.sh "$concurrency_limit"
    - docker container exec "$container" rm -rf '/tmp/*'
    - rm -rf ./${IMAGE_KIND}/cache/conan-home/
    - mkdir -p ./${IMAGE_KIND}/cache/
    - docker container cp "$container:/root/.conan2/" ./${IMAGE_KIND}/cache/conan-home
    - docker container stop "$container"
    - docker container commit --message 'Add Conan packages' "$container" ${CONTAINER_IMAGE}

    - echo "==== Pushing image ===="
    - docker push ${CONTAINER_IMAGE}
  cache:
    key: docker-builder-cache
    paths:
      - ./${IMAGE_KIND}/cache/

builder/ubuntu-2204:
  extends: .conan-builder
  variables:
    IMAGE_NAME: ubuntu-2204

builder/ubuntu-rolling:
  extends: .conan-builder
  variables:
    IMAGE_NAME: ubuntu-rolling

builder/flatpak:
  stage: conan-install
  needs:
    - merge-lockfiles
  tags:
    - docker
  image: docker
  <<: *rules_only_when_building
  variables:
    IMAGE_KIND: builder
    IMAGE_NAME: flatpak
    CONTAINER_IMAGE: ${PROJECT_REGISTRY}/${IMAGE_KIND}-${IMAGE_NAME}:${IMAGE_TAG_TEST}
  services:
    - docker:dind
  script:
    - *set_concurrency_limit
    - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
    - echo '==== Executing Flatpak Builder with Conan in container ===='
    # --privileged is necessary for flatpak-builder, see https://github.com/flatpak/flatpak-builder/issues/237
    - container="$(docker container run --privileged --interactive --detach ${CONTAINER_IMAGE})"
    #TODO Cache ~/.conan2 like above?
    - docker container cp ./${IMAGE_KIND}/flatpak/ "$container:/tmp/flatpak"
    - docker container cp ./${IMAGE_KIND}/conan/ "$container:/tmp/conan"
    - |
      if [ -n "$concurrency_limit" ]; then
        concurrency_option="--jobs=$concurrency_limit"
      fi
    # Generate base image for nl.ru.cs.pep.client.yml and save as /pep-base.flatpak
    - docker container exec "$container" flatpak-builder $concurrency_option --repo /tmp/flatpak/repo /tmp/flatpak/build /tmp/flatpak/nl.ru.cs.pep.base.yml
    - docker container exec "$container" flatpak build-bundle /tmp/flatpak/repo /pep-base.flatpak nl.ru.cs.pep.base --runtime-repo=https://flathub.org/repo/flathub.flatpakrepo
    - docker container exec "$container" rm -rf '/tmp/*'
    - docker container stop "$container"
    - docker container commit --message 'Build base flatpak with Conan packages' "$container" ${CONTAINER_IMAGE}

    - echo '==== Pushing image ===='
    - docker push ${CONTAINER_IMAGE}

###
#TODO This doesn't actually test if images work for stable/release, where no full build is performed in the initial pipeline
test-images:
  stage: analyze
  rules:
    - *no_mr_pipelines
    - *not_if_retagging_parent
    # Enable if we force it to
    - if: $FORCE_TEST
      when: on_success
    # Enable on schedule branches
    - if: $CI_COMMIT_BRANCH =~ $SCHEDULE_BRANCHES_REGEX
      when: on_success
  tags:
    - docker-small
  image: alpine
  script:
    - apk add --no-cache jq curl
    - ./run-pipeline.sh ${IMAGE_TAG_TEST} "${CORE_TEST_REF}" "${MERGE_LOCKFILES_JOB}"

test-images-manual:
  stage: analyze-manual
  when: manual
  tags:
    - docker-small
  image: alpine
  script:
    # We don't check $NEW_IMAGE here, because we want to make sure that when a commit is added to a different branch,
    #  we run a pipeline in PEP core in the corresponding branch
    - apk add --no-cache jq curl
    - ./run-pipeline.sh ${IMAGE_TAG} "${CORE_TEST_REF}" "${MERGE_LOCKFILES_JOB}"

###
retag-images:
  stage: deploy
  tags:
    - docker-small
  image: docker
  <<: *rules_only_when_building
  script:
    # A better way to skip jobs is not yet available, see https://gitlab.com/gitlab-org/gitlab/-/issues/292816, https://gitlab.com/gitlab-org/gitlab/-/issues/329217
    # $NEW_IMAGE, $LOCKFILE_CHANGED are retrieved from jobs above via env.env
    - if [ -z "$NEW_IMAGE" ]; then exit; fi
    - if [ -n "$LOCKFILE_CHANGED" ]; then exit; fi
    - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
    - |
      for image in ${DEPLOY_IMAGES}; do
        echo "Retagging $image:${IMAGE_TAG_TEST} as ${PROJECT_REGISTRY}/$image:${IMAGE_TAG}"
        # This assumes sha-test tags of an image will not be cleaned up if it is still recent and thus reused
        docker buildx imagetools create --tag ${PROJECT_REGISTRY}/$image:${IMAGE_TAG} ${PROJECT_REGISTRY}/$image:${IMAGE_TAG_TEST}
      done

retag-parent-images:
  stage: deploy
  tags:
    - docker-small
  image: docker
  rules:
    - *no_mr_pipelines
    - if: $RETAG_PARENT_COMMIT_IMAGES
      when: on_success
  script:
    - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
    - |
      for image in ${DEPLOY_IMAGES}; do
        echo "Retagging $image:${PARENT_IMAGE_TAG} as ${PROJECT_REGISTRY}/$image:${IMAGE_TAG_TEST}"
        docker buildx imagetools create --tag ${PROJECT_REGISTRY}/$image:${IMAGE_TAG_TEST} ${PROJECT_REGISTRY}/$image:${PARENT_IMAGE_TAG}
        echo "Retagging $image:${PARENT_IMAGE_TAG} as ${PROJECT_REGISTRY}/$image:${IMAGE_TAG}"
        docker buildx imagetools create --tag ${PROJECT_REGISTRY}/$image:${IMAGE_TAG} ${PROJECT_REGISTRY}/$image:${PARENT_IMAGE_TAG}
      done

update-core:
  stage: deploy
  needs:
    - retag-images
    - merge-lockfiles
  rules:
    - *no_mr_pipelines
    - *not_if_retagging_parent
    # Enable on schedule branches
    - if: $CI_COMMIT_BRANCH =~ $SCHEDULE_BRANCHES_REGEX
      when: on_success
  tags:
    - docker-small
  image: alpine
  variables:
    GIT_STRATEGY: none  # Do not fetch nor clean working tree
  before_script:
    - apk add --no-cache git openssh jq curl
  script:
    - if [ -z "$LOCKFILE_CHANGED" ]; then exit; fi
    - |
      mkdir -p ~/.ssh
      >>~/.ssh/known_hosts echo "${CI_SERVER_HOST},131.174.138.131 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDd/zrrJ+9MjUvHBq55u3sdP6Tu+lqA+zCwFDeHtLSl40sOGZvDQ1AE/R6bnQQTSQ+GKUFdwHAar7ePVCBXeDhw="
      eval $(ssh-agent -s)
      echo "${SSH_KEY_GITLAB}" | tr -d '\r' | ssh-add -
      git config --global user.email support@pep.cs.ru.nl
      git config --global user.name 'Gitlab CI script from docker-build'
      rm -rf ./pep
    - >
      git clone --branch="${CI_COMMIT_REF_NAME}"
      --sparse
      --no-tags
      --depth=1
      --shallow-submodules
      --recurse-submodules=docker-build
      "git@${CI_SERVER_HOST}:${CORE_PROJECT}.git" ./pep
    - |
      echo 'Updating docker-build'
      (
      cd ./pep/docker-build/
      if [ "$(git rev-parse "${CI_COMMIT_REF}")" != "${CI_COMMIT_SHA}" ]; then
        >&2 echo "This (${CI_COMMIT_SHA}) is not the newest docker-build commit"
        exit 1
      fi
      git checkout "${CI_COMMIT_REF}"
      mv -f ../../conan.lock ./builder/conan/
      git add .
      git commit -m "Update conan.lock for pipeline ${CI_PIPELINE_ID}
      ${CI_JOB_URL}"
      git push -o ci.variable='RETAG_PARENT_COMMIT_IMAGES=yes'
      echo "Made commit at: ${CI_PROJECT_URL}/-/commit/$(git rev-parse HEAD)"
      )
    - |
      echo 'Updating core'
      sed --in-place "/s/(RUNNER_IMAGE_TAG:\s*)\S*/\1${IMAGE_TAG}/" ./ci_cd/docker-common.yml
      if git diff --no-patch --exit-code ./ci_cd/docker-common.yml; then
        # No differences
        >&2 echo "Failed to update /ci_cd/docker-common.yml in ${CORE_PROJECT}"
        exit 1
      fi
      git add .
      git commit -m "Update docker-build for pipeline ${CI_PIPELINE_ID}
      ${CI_JOB_URL}"
      git push
      echo "Made commit at: ${CI_SERVER_URL}/${CORE_PROJECT}/-/commit/$(git rev-parse HEAD)"
